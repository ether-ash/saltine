{-# LANGUAGE OverloadedStrings #-}

module HashProperties (
  testHash
  ) where

import           Util
import           Crypto.Saltine.Class
import           Crypto.Saltine.Core.Hash
import qualified Crypto.Saltine.Internal.ByteSizes as Bytes
import           Crypto.Saltine.Unsafe.Hash
import           Crypto.Saltine.Unsafe.PasswordHash

import qualified Data.ByteString                      as S
import           Data.Maybe                             (fromJust)
import           Test.Framework.Providers.QuickCheck2
import           Test.Framework
import           Test.QuickCheck




abc, shaDigestAbc :: S.ByteString
abc = "abc"
shaDigestAbc = S.pack
    [0xdd,0xaf,0x35,0xa1,0x93,0x61,0x7a,0xba
    ,0xcc,0x41,0x73,0x49,0xae,0x20,0x41,0x31
    ,0x12,0xe6,0xfa,0x4e,0x89,0xa9,0x7e,0xa2
    ,0x0a,0x9e,0xee,0xe6,0x4b,0x55,0xd3,0x9a
    ,0x21,0x92,0x99,0x2a,0x27,0x4f,0xc1,0xa8
    ,0x36,0xba,0x3c,0x23,0xa3,0xfe,0xeb,0xbd
    ,0x45,0x4d,0x44,0x23,0x64,0x3c,0xe8,0x0e
    ,0x2a,0x9a,0xc9,0x4f,0xa5,0x4c,0xa4,0x9f]

deflen :: Int
deflen = Bytes.generichash

blakeKey :: GenerichashKey
blakeKey = fromJust . decode $ S.pack
    [0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07
    ,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f
    ,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17
    ,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f
    ,0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27
    ,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f
    ,0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37
    ,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f]

blakeTest :: S.ByteString
blakeTest = S.pack
    [0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07
    ,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f]

blakeDigest :: S.ByteString
blakeDigest = S.pack
    [0xa0,0xc6,0x5b,0xdd,0xde,0x8a,0xde,0xf5
    ,0x72,0x82,0xb0,0x4b,0x11,0xe7,0xbc,0x8a
    ,0xab,0x10,0x5b,0x99,0x23,0x1b,0x75,0x0c
    ,0x02,0x1f,0x4a,0x73,0x5c,0xb1,0xbc,0xfa
    ,0xb8,0x75,0x53,0xbb,0xa3,0xab,0xb0,0xc3
    ,0xe6,0x4a,0x0b,0x69,0x55,0x28,0x51,0x85
    ,0xa0,0xbd,0x35,0xfb,0x8c,0xfd,0xe5,0x57
    ,0x32,0x9b,0xeb,0xb1,0xf6,0x29,0xee,0x93]

pwhashFilter :: S.ByteString -> Bool
-- XXX: horrifying hack to reduce the amount of Argon2 hashing
--      from 20000 to on average ~80 tests
pwhashFilter bs = S.head (hash bs) /= 0

testHash :: Test
testHash = buildTest $
  return $ testGroup "...Internal.Hash" [

    testProperty "hash a /= hash b"
    $ \(ByteString32 a) (ByteString32 b) ->
        a /= b ==> hash a /= hash b,

    testProperty "generichash a /= generichash b"
    $ \(ByteString32 a) (ByteString32 b) ->
        a /= b ==> generichash a deflen Nothing /= generichash b deflen Nothing,

    testProperty "generichash m k_a /= generichash m k_b"
    $ \(ByteString32 m) (ByteString32 k_a') (ByteString32 k_b') ->
        k_a' /= k_b' ==>
        let Just k_a = decode k_a'
            Just k_b = decode k_b'
        in generichash m deflen (Just k_a) /= generichash m deflen (Just k_b),

    testProperty "matches test vector for SHA-512"
    $ hash abc == shaDigestAbc,

    testProperty "matches test vector for Blake2b"
    $ generichash blakeTest 64 (Just blakeKey) == blakeDigest,

    testProperty "hash and verify password with interactive limits"
    $ \(Message pass) -> pwhashFilter pass ||
        pwhashStrVerify pass (pwhashStr pass interactivePolicy),

    testProperty "hash and verify password with moderate limits"
    $ \(Message pass) -> pwhashFilter pass ||
        pwhashStrVerify pass (pwhashStr pass moderatePolicy),

    testProperty "hash and verify password with sensitive limits"
    $ \(Message pass) -> pwhashFilter pass ||
        pwhashStrVerify pass (pwhashStr pass sensitivePolicy)

    ]
