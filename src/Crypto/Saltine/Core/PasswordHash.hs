{-# LANGUAGE RecordWildCards #-}
-- |
-- Module      : Crypto.Saltine.Core.PasswordHash
-- Copyright   : (c) Joseph Abrahamson 2013
-- License     : MIT
--
-- Maintainer  : me@jspha.com
-- Stability   : experimental
-- Portability : non-portable
--
-- Hashing: "Crypto.Saltine.Core.PasswordHash"
--
-- The 'pwHashStr' function takes a password the maximum number of
-- operations and the amount of ram and returns a hash. Hashes are
-- always of length 'Bytes.passWord'.
--
-- pwHash and pwHashStr are currently based on an implementation of argon2.
module Crypto.Saltine.Core.PasswordHash (
  HashingPolicy(..),
  EncryptedPass,
  moderatePolicy,
  genSalt,
  pwHash,
  pwHashStr,
  pwHashStrVerify
  ) where

import Crypto.Saltine.Internal.Util
import qualified Crypto.Saltine.Internal.ByteSizes as Bytes

import Foreign.C
import Foreign.Ptr
import qualified Data.ByteString as B

-- $types

-- | Encapsulates the tuning values for the c_pwhash functions
data HashingPolicy = HashingPolicy
  -- | Maximum amount of computations to perform.
  -- Raising this number will make the function require more CPU cycles
  -- to compute a key.
  { opsLimit :: Int
  -- | Maximum amount of RAM that the function will use, in bytes.
  -- It is highly recommended to allow the function to use at least 16
  -- megabytes.
  , memLimit :: Int
  }

-- | A policy for highly sensitive data. It should be noted that deriving
-- a key with this policy takes about 2 seconds on a 2.8 Ghz Core i7 CPU
-- and requires up to 1 gigabyte of dedicated RAM.
sensitivePolicy :: HashingPolicy
sensitivePolicy = HashingPolicy
  { opsLimit = Bytes.opslimitSensitive
  , memLimit = Bytes.memlimitSensitive
  }

-- | A policy for moderately sensitive data. Somewhere between sensitivePolicy
-- and interactivePolicy
moderatePolicy :: HashingPolicy
moderatePolicy = HashingPolicy
  { opsLimit = Bytes.opslimitModerate
  , memLimit = Bytes.memlimitModerate
  }

-- | A policy for interactive, online operations. Safe base line for the
-- parameters, for more sensitive data it's recommended to use higher
-- values
interactivePolicy :: HashingPolicy
interactivePolicy = HashingPolicy
  { opsLimit = Bytes.opslimitInteractive
  , memLimit = Bytes.memlimitInteractive
  }

-- | ASCII encoded String containing the result of the
-- hash function, the automatically generated salt and the two parameters
-- opslimit and memlimit.
type EncryptedPass = B.ByteString

-- | Randomly Generated Salt with a length of 'Bytes.salt'
newtype Salt = Salt {salt :: B.ByteString}

-- | Generates new random salt
genSalt :: IO Salt
genSalt = do
  salt <- randomVector Bytes.salt
  return Salt{..}

-- | Derives a key from a password and a salt salt.
-- If 'Int' <= 16 the function returns a 16 Bytes long 'ByteString' of \Null
pwHash :: Int
       -- ^ Length of resulting key
       -> B.ByteString
       -- ^ Password
       -> Salt
       -- ^ Salt
       -> HashingPolicy
       -- ^ used HashingPolicy
       -> B.ByteString
pwHash keyLen pass Salt{..} HashingPolicy{..} =
  snd . buildUnsafeCVector keyLen
    $ \k -> constVectors [pass, salt] $ \[(pp, pl), (ps, _)] ->
      c_pwhash k (fromIntegral keyLen) pp (fromIntegral pl) ps
        (fromIntegral opsLimit) (fromIntegral memLimit)

-- | Computes an ASCII encoded string containing the result of the
-- hash function, the automatically generated salt and the two parameters
-- opslimit and memlimit.
--
-- The output string is zero-terminated, includes only ASCII characters
-- and can be safely stored into SQL databases and other data stores.
-- No extra information has to be stored in order to verify the password.
pwHashStr :: B.ByteString
          -- ^ Password
          -> HashingPolicy
          -- ^ used HashingPolicy
          -> EncryptedPass
pwHashStr pass HashingPolicy{..} =
   snd . buildUnsafeCVector Bytes.passwordHash
    $ \ph -> constVectors [pass] $ \[(pm, pl)] ->
    c_pwhash_str ph
      pm (fromIntegral pl)
      (fromIntegral opsLimit) (fromIntegral memLimit)

-- This function verifies that the string ,'EncryptedPass', is a valid password verification string (as generated by pwHashStr for passwd 'ByteString'.
pwHashStrVerify :: B.ByteString
                -> EncryptedPass
                -> Bool
pwHashStrVerify pass ePass =
  unsafeDidSucceed
    $ constVectors [pass, ePass] $ \[(pPass, pPassLen), (pEpass, _ )] ->
    return $ c_pwhash_str_verify pEpass pPass (fromIntegral pPassLen)

foreign import ccall "crypto_pwhash"
  c_pwhash :: Ptr CChar
           -- ^ Output key buffer
           -> CULLong
           -- ^ Key buffer length
           -> Ptr CChar
           -- ^ Constanct password buffer
           -> CULLong
           -- ^ Constant password buffer length
           -> Ptr CChar
           -- ^ Constant Salt buffer
           -> CULLong
           -- ^ Maximum number of operations to perform
           -> CSize
           -- ^ Maximum amount of RAM the function will use
           -> IO Int
           -- ^ 0 on success, -1 for failure

foreign import ccall "crypto_pwhash_str"
  c_pwhash_str :: Ptr CChar
               -- ^ Output hash buffer
               -> Ptr CChar
               -- ^ Constant password buffer
               -> CULLong
               -- ^ Password buffer length
               -> CULLong
               -- ^ Maximum number of operations to perform
               -> CSize
               -- ^ Maximum amount of RAM the function will use
               -> IO Int
               -- ^ 0 on success, -1 on failure

-- | We don't even include this in the IO monad since all of the
-- buffers are constant.
foreign import ccall "crypto_pwhash_str_verify"
  c_pwhash_str_verify :: Ptr CChar
                      -- ^ Constant hash string buffer as returned
                      -- from pwHashStr
                      -> Ptr CChar
                      -- ^ Constant password buffer
                      -> CULLong
                      -- ^ Password buffer length
                      -> CInt
                      -- ^ 0 on success, -1 on failure
